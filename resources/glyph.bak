
''' 
glyph.py
Cover methods for bokeh functionality
'''


from bokeh.plotting import figure, output_notebook, curdoc, ColumnDataSource, show
from bokeh.models import Label 

class InvalidParamEntry(Exception):
    """Raised when invalid parameter is passed"""
    
class InvalidTypeError(Exception):
    """Raised when invalid type passed as a parameter"""
    
class InvalidBokehConfiguration(Exception):
    """Raised when Bokeh objects are not configured correctly"""
    
class InvalidShapeError(Exception):
    """Raised when invalid shaped passed to make_points"""
    

class Glyph: 

    
    def __init__(self, title : str = "New Title", width : int = 650, height : int = 450, x_axis_label :str = ''
                 , show_ticks : bool = True, y_axis_label : str = '', theme : str = 'dark_minimal'
                 , palettes: [] = ['dodgerblue', 'forestgreen', 'darkorange']):
        
        self.title = title
        self.width = width
        self.height = height 
        self.x_axis_label = x_axis_label
        self.y_axis_label = y_axis_label
        self.theme = theme 
        self.palettes = palettes
        self.show_ticks = show_ticks
        self.color = 0
        self.plot = self.make_plot() 
        self.plots = 0
        

        
        
        
    # def get_color(self):
    #     color = -1
    #     def inner_func():
    #         nonlocal color
    #         num += 1
    #         return self.palettes[num]
    #     return inner_func
    
    # color = get_color()
        
        
    def make_plot(self): 
        """
        create a bokeh figure based on title, width, height, theme 
        passed as arguments or default values at object creation 
        
        Parameters 
        ----------
        None

        Returns
        -------
        None
        """
        
        print('INSIDE MAKE PLOT')

        output_notebook(hide_banner=True)
        
        curdoc().theme = self.theme 
        
        p = figure(
            title = self.title
            , width = self.width
            , x_axis_label = self.x_axis_label
            , y_axis_label = self.y_axis_label
            ,height = self.height
        )
        
        if not self.show_ticks:
            p.xaxis.major_tick_line_color = None
            p.yaxis.major_tick_line_color = None
            p.xaxis.major_label_text_font_size = '0pt'
            p.yaxis.major_label_text_font_size = '0pt'
        return p
    
    
    
    def get_blue_palette(self):
        from bokeh.palettes import Blues
        return Blues 
        
        
        
    def make_line(self, x : [], y : [],  width : int = 1, label : str = "",  color : str = "dodgerblue", alpha : float = .90):
        """
        create a bokeh figure.line based on x and y values
        the line width (default = 1) and line color (default None) can be set with parameters
        
        Parameters 
        ----------
        x : list, mandatory - a list that consisted of the x-axis values
        y : list, mandatory - a list that consisted of the y-axis values
        width : int - a value that represent line width
        label : str - 'the string value that denotes the line

        Returns
        -------
        None
        """
        
        source = ColumnDataSource(
            dict(x = x, y = y)
        )        
        if len(label) > 0:          
            self.plot.line(
                x = 'x'
                ,y = 'y'
                ,line_width = width 
                ,color = color
                ,alpha = alpha
                ,legend_label = label 
                ,source = source 
            )
        else: 
            self.plot.line(
                x = 'x'
                ,y = 'y'
                ,line_width = width 
                ,color = color
                ,source = source 
            )
        self.plots += 1
         
                   
    def make_vert_line(self
                       , x
                       , data_point : int | float
                       , y_min : int | float = 0
                       , mu : int | float = 0
                       , sigma : int | float = 0
                       , width : int = 1
                       , label : str = ""
                       , color : str = 'firebrick'
                       ,alpha : float = 0.75
                    ):
        """
        create a bokeh figure.line which will be vertical based on x, mu, sigma 
         
        Parameters 
        ----------
        x : 
        data_point : int | float, mandatory - a data point along the x axis of the distribution 
        mu  : int | float- the mean of the distribution of which the vertical line will be displayed
        sigma : int | float - the standard deviation of the distribution of which the vertical line will be displayed 
        width : int - a value that represent line width
        label : str - 'the string value that denotes the line

        Returns
        -------
        None
        """  
        if self.plots > 0:
            import sys
            sys.path.insert(0, '..')
            import resources.datum as data
            new_data = data.Data()
            y_point = new_data.get_normal_dist(data_point, mu, sigma)
            x = [data_point, data_point]
            y = [y_min, y_point]
            print(f'{label}\ny_MIN:{y_min}\ny_MAX:{y_point}')
            from bokeh.plotting import ColumnDataSource
            source = ColumnDataSource(
                dict(x = x, y = y)
            )
            if len(label) > 0:          
                self.plot.line(
                    x = 'x'
                    ,y = 'y'
                    ,line_width = width 
                    ,color = color
                    ,alpha = alpha 
                    ,legend_label = label 
                    ,source = source 
                )
            else: 
                self.plot.line(
                    x = 'x'
                    ,y = 'y'
                    ,line_width = width 
                    ,color = color
                    , alpha = alpha
                    , source = source 
                )
            self.plots += 1
        else:
            raise InvalidBokehConfiguration
            
            
    def make_varea(self 
                   , x 
                   , y
                   , floor
                   , fill_color : str = 'dodgerblue' 
                   , fill_alpha : float = 0.75
                   , legend_label : str = ''
                   ):
        """
        create a bokeh figure.area which is vertically directed based on x, y1, and y2 values 
         
        Parameters 
        ----------
        x : list | ndarray, mandatory - The x-coordinates for the points of the area.
        floor: list | ndarray, mandatory - The zero value y-coordinates for the bottom side of the area
        y: list | ndarray, mandatory - The value y-coordinates for the side side of the area
        data_point : int | float, mandatory - a data point along the x axis of the distribution 
        fill_color : str, optional, - color of the area, default - dodger blue
        fill_alpha : float, optional - alpha value for the file_color, default 0.75
        legend_label : str - 'the string value that denotes the line

        Returns
        -------
        None
        """  
        source = ColumnDataSource(
            dict(x = x, floor = floor, y = y)
        )
        if len(legend_label) > 0:
            self.plot.varea(
                x = 'x'
                , y1 = 'floor' 
                , y2 = 'y'
                , fill_color = fill_color
                , fill_alpha = fill_alpha
                , legend_label = legend_label 
                ,source = source 
            )
        else:
            self.plot.varea(
                x = 'x'
                , y1 = 'floor' 
                , y2 = 'y'
                , fill_color = fill_color
                , fill_alpha = fill_alpha
                , source = source 
            )
            
            
    def make_column_datasource(self, source : dict ):
        if isinstance(source, dict):
            for key, value in source.items():
                all([(not isinstance(key, str)),  (not isinstance(value, list))])
                raise InvalidParamEntry(Exception)
          
    
    def add_label(self
            ,text : str = 'New Label'
            ,text_color = 'gainsboro'
            ,x_loc : int= 250 
            ,y_loc : int = 75    
            ,line_color : str = None
            ,line_alpha : float = 0.90
            ,fill_color : str = None
            ,fill_alpha : float = 0.50
            
        ):

        
        
        label = Label(x=x_loc, y=y_loc, x_units='screen', y_units='screen', text= text,
                        text_color= text_color, border_line_color = line_color, border_line_alpha=line_alpha,
                        background_fill_color=fill_color, background_fill_alpha=fill_alpha)
        self.plot.add_layout(label)
        
    
    def make_points(self
                   ,shape : str = ''
                   , x_arr : list = []
                   , y_arr : list = []
                   , size : int = 5
                   , fill_color : str = 'firebrick'
                   , line_color : str = 'firebrick'
                   , alpha : float = 0.90
                   ,label : str = ''
          ):
        """
        create a bokeh figure.shape array (circle, square, diamond, triangle, star)
         
        Parameters 
        ----------
        shape : str mandatory - circle, square, diamond, triangle, or star
        x_arr : list  mandatory - The x-coordinates for the shape(s)
        y_arr : list  mandatory - The y-coordinates for the shape(s)
        size  : int - optional the size of the shape, default 5
        fill_color : str, optional, - fill color of the shape
        line_cole : str, optional, - line color of the shape
        fill_alpha : float, optional - alpha value for the file_color, default 0.90
        legend_label : str - 'the string value that denotes the shape, de

        Returns
        -------
        None
        """  
        if self.plots > 0:
            if isinstance(shape, str):
                if len(shape) < 1:
                    raise InvalidParamEntry(Exception)
                if all([isinstance(x_arr, list), isinstance(y_arr, list), isinstance(size, int), isinstance(fill_color, str), isinstance(alpha, float), isinstance(line_color, str)]):
                    if len(label) < 4:
                        label = shape
                    match shape:
                        case 'circle':
                            self.plot.circle(x = x_arr, y = y_arr, size = size, fill_color = fill_color, fill_alpha = alpha, legend_label = label, line_color = line_color)
                        case 'square':
                            self.plot.square(x = x_arr, y = y_arr, size = size, fill_color = fill_color, fill_alpha = alpha, legend_label = label, line_color = line_color)
                        case 'diamond':
                            self.plot.diamond(x = x_arr, y = y_arr, size = size, fill_color = fill_color, fill_alpha = alpha, legend_label = label, line_color = line_color)
                        case 'triangle':
                            self.plot.triangle(x = x_arr, y = y_arr, size = size, fill_color = fill_color, fill_alpha = alpha, legend_label = label, line_color = line_color)
                        case 'star':
                            self.plot.star(x = x_arr, y = y_arr, size = size, fill_color = fill_color, fill_alpha = alpha, legend_label = label, line_color = line_color)
                        case _:
                            raise InvalidShapeError(shape)
                
                else:
                    raise InvalidParamEntry(Exception)
            else:
                raise InvalidParamEntry(Exception)
        else:    
            raise InvalidBokehConfiguration(shape)
        
        
    def make_histogram(self 
                   , x 
                   , start : int = 0
                   , stop : int = 0
                   , bins : int = 0
                   , mu : int | float = 0
                   , sigma : int | float = 0
                   , fill_alpha : float = 0.90 
                   , fill_color : str = 'dodgerblue'
                   , line_color : str = 'white'
                   , pdf : bool = False
                   , legend_label = ''
                   ):
        
        """
        create a bokeh histogram based on a list, bin parameters (start, stop, bin size)
         
        Parameters 
        ----------
        x : list | ndarray, mandatory - The population of the histogram
        start: int , mandatory - The minimal value of population
        stop: int , mandatory - The minimal value of population
        bins: int, mandatory - Number of bins - 1 (if 10, then 9 bins will be created)
        fill_alpha : float, optional - alpha value for the file_color, default 0.90
        fill_color : str, optional, - color of the area, default - dodger blue
        pdf : bool - if true draw a probability density function line based on histogram value
        Returns
        -------
        Histogram
        """  
        if all([isinstance(start, int | float), isinstance(stop, int | float), isinstance(bins, int), 
                isinstance(mu, int | float), isinstance(sigma, int | float),  isinstance(pdf, bool)]):
            if all([start > 0, start > 0, stop > 0]):
                if len(legend_label) < 2:
                    legend_label = 'histogram' 
                import numpy as np
                import sys
                sys.path.insert(0, '..')
                import resources.datum as datum 
                data = datum.Data()
                
                bin_cnt = np.linspace(start, stop, bins)
                hist, edges = np.histogram(x, density=True, bins = bin_cnt)
                self.plot.quad(top = hist
                    ,bottom=0 
                    ,left = edges[:-1] 
                    ,right= edges[1:]
                    ,fill_color = fill_color  
                    ,alpha = fill_alpha
                    ,line_color = line_color
                    ,legend_label = legend_label
                )
                print(len(x), mu, sigma)
                if pdf:
                    if len(x) < 200:
                        n = len(x) * 2
                    else:
                        n = len(x)  # noqa: F841
                    
                    xx = np.linspace(np.min(x), np.max(x), len(x))
                    y = data.get_normal_dist(x = xx, mu = mu, sigma = sigma)
                    self.make_line(x = xx, y = y)
            else:
                err_msg = f'start ({start}), stop ({stop}), bins ({bins}) must have values greater than 0'
                raise InvalidParamEntry(err_msg)        
        else:        
            err_msg = 'either start, stop, or bins is an invalid type'
            raise InvalidTypeError(err_msg)                            
              
    def show(self):
        show(self.plot)
        
        


