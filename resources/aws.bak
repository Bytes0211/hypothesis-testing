# LAST UPDATED 6/20/2022 : 7:51 PM 

import uuid
import boto3 as aws
import requests 
import io 
import resources.util as util



class Aws:
    """
    A class to represent a aws s3 bucket and behaviors.

    ...

    Attributes
    ----------
        None

    Methods
    -------
    def __init__(self, s3_client, s3_resource, iam_client, lambda_client) -> None:
        initializes boto3 s3 client, s3 resource, iam client, lambda client objects

    def create_bucket_name(self, *args : str) -> str:
        Creates a bucket name ensuring that the name is unique using uuid

    def create_bucket(self, bucket_prefix, resource):
        creates a bucket in aws using the name generated with the create_bucket name method.

    def list_buckets(self):
        creates a list of of buckets associated with the executing profile

    def list_bucket_files(self, bucket_list_name):
       retrieves list of objects associated with the bucket_list_name 


    def add_file_to_bucket(self, bucket_name, file_name):
        Add file to bucket

    def copy_to_bucket(self, from_bucket, to_bucket, file_name):
        Copy an s3 object from bucket to bucket

    def delete_files_from_bucket(self, bucket_name, file_list):
        '''
            delete files from existing s3

    def enable_bucket_versioning(self, bucket_name:str):
        generate a version for a bucket.

    def __init__(self, client, resource) -> None:
        initializes aws lambda client and aws lambda resource objects

    def list_iam_roles(self)->dict:
        Creates a list of all aws iam roles in aws account

    def validate_iam_role(self, role):
        validates iam role exist in account  

    def __init__(self, client, resource) -> None:
        initializes aws lambda client and aws lambda resource objects

    def list_iam_roles(self):
        list iam roles in account 

    def validate_iam_role(self, role):
        validates iam role exist in account

    def deploy_function(self, role, file, func_name, description, env):
        deploys zip file to aws as a lambda

    def invoke_lambda(self, name, test_event):
        invokes aws lambda remotely 

    def describe_lambda(self, name):
        describes aws lambda 

    def update_function(self, name:str, file_loc:str)->str:
        updates
    """

    
    def __init__(self) -> None:
    # def __init__(self, s3_client, s3_resource, iam_client, lambda_client) -> None:
        """
        Constructs all the necessary attributes for the bucket object.

            Parameters
            ----------
                client : boto3 aws s3 client object 
                    client object used as a conduit to interact with aws s3 objects 
                resource : boto3 aws s3 resource  object
                    resource object conduit to interact with aws s3 objects
        """
        self.s3_client = None
        self.s3_resource = None
        self.iam_client = None
        self.lambda_client = None
        self.msg = None
        
    def get_s3_client(self):
        '''
        gets s3 client attribute for class instance

            Parameters:
            ----------
                None
            Returns:
                s3_client (boto3 s3 client object): s3 client object
        '''
        if not self.s3_client:
            self.s3_client = util.get_s3_client()
        return self.s3_client
    
    def get_s3_resource(self):
        '''
        gets s3 resource attribute for class instance

            Parameters:
            ----------
                None
            Returns:
                s3_resource (boto3 s3 resource object): s3 resource object
        '''
        if not self.s3_resource:
            self.s3_resource = util.get_s3_resource()
        return self.s3_resource

    def get_iam_client(self):
        '''
        gets iam client attribute for class instance

            Parameters:
            ----------
                None
            Returns:
                iam_client (boto3 iam client object): iam client object
        '''
        if not self.iam_client:
            self.iam_client = util.get_iam_client()
        return self.iam_client
    
    def get_lambda_client(self):
        '''
        gets lambda client attribute for class instance

            Parameters:
            ----------
                None
            Returns:
                lambda_client (boto3 lambda client object): lambda client object
        '''
        if not self.lambda_client:
            self.lambda_client = util.get_lambda_client()
        return self.lambda_client

    def set_msg(self, msg:str):
        '''
        sets message attribute for class instance

            Parameters:
            ----------
                msg (str): message string 
            Returns:
                msg (str): message string 
        '''
        self.msg = msg
        
    def get_msg(self)-> str:
        '''
        gets message attribute for class instance

            Parameters:
            ----------
                None
            Returns:
                msg (str): message string 
        '''
        if not self.msg:
            self.msg = 'No message set'
        return self.msg


    
    

    def create_bucket_name(self, *args : str) -> str:
        '''
        Creates a bucket name ensuring that the name is unique using uuid

            Parameters:
            ----------
                #args as string name, using default name if none is passed in      
            Returns:
                bucket name as string 
        '''
        # The generated bucket name must be between 3 and 63 chars long
        try: 
            default_name = 'scotton'
            if args == None or len(args) == 0:
                return ''.join([default_name, str(uuid.uuid4())])
            else: 
                return ''.join([args[0], str(uuid.uuid4())[:8]]) # I will only use the first 8 chars of the uuid
        except Exception as e:
            err = f'An Exception occured creating bucket name:\n {e} '
            print(err)
            return err

    def create_bucket(self, bucket_prefix, s3_resource):
        '''
        creates a bucket in aws using the name generated with the create_bucket name method.

            Parameters:
            ----------
                bucket_prefix (str): the prefix of the bucket name
                resource (aws resource): s3 resource meta client 

            Action: 
            -------
                creates s3 bucket in aws

            Returns:
            --------
                Name of bucket (str) , s3 response  
        ''' 
        try:
            session = aws.session.Session()
            current_region = session.region_name
            #bucket_name = create_bucket_name(bucket_prefix)
            # bucket_name = 'aws-sam-cli-managed-default-samclisourcebucket-1tcgb3olhz2nc'
            bucket_name = self.create_bucket_name(bucket_prefix)
            bucket_response = self.get_s3_resource().create_bucket(
                Bucket=bucket_name,
            # only works and required outside of us CreateBucketConfiguration={'LocationConstraint': current_region}
            )
            print(bucket_name, current_region)
            return bucket_name, bucket_response
        except Exception as e:
            err = f'AN ERROR OCCURED CREATEDING BUCKET {bucket_prefix}:::\n{e}'
            print(err)

    def list_buckets(self):
        '''
        creates a list of of buckets associated with the executing profile
            Parameters: 
            ----------
                None

            Action: 
            -------
                List all buckets associated with account

            Returns:
            --------
                bucket list   
        ''' 
        try:
            bucket_list = [] 
            resp = self.get_s3_client().list_buckets()
            for bucket in resp['Buckets']:
                bucket_list.append(bucket['Name'])
            return bucket_list
        except Exception as e:
            err = f'AN EXCEPTION OCCURED LISTING BUCKETS::::\n{e} '
            print(err)


    def list_bucket_files(self, bucket_list_name):
        """
        retrieves list of objects associated with the bucket_list_name 

            Parameters
            ----------
            bucket_list_name : str
                The name of the bucket to reference in aws which we are retrieving objects 

            Returns
            -------
            list : List of objects in the parameter bucket_list_name 
        """
        try: 
            response = self.get_s3_client().list_objects_v2(Bucket = bucket_list_name)
            object_list = []
            if response["KeyCount"] > 0:
                for x in response['Contents']:
                    if x['Size'] > 0:
                        # obj_dict = {'Name' : x['Key'], 'Size' : x['Size'], 'StorageClass' : x['StorageClass']}
                        obj_str = f'Name: {x["Key"]}\n\tSize: {x["Size"]}\n\tStorageClass: {x["StorageClass"]}\n'
                        object_list.append(obj_str)
            else:
                object_list.append('Bucket Is Empty')
            return object_list
        except Exception as e:
            err = f'AN EXCEPTION OCCURED CREATING FILE LIST FOR BUCKET: {bucket_list_name}\n{e}'
            print(err)



    def add_file_to_bucket(self, payload : dict):
        ''' 
            Add file to bucket\n
            if url is provided , down load file from url\n
            If url is not provided, file string should be a file path\n
            Parameters:
            ----------
                payload (dict): dictionary of file parameters
                    payload[file_name] (str):name of file 
                    payload[bucket_name] (str): name of bucket to add file to
                    payload[object_name] (str): txt file with optional folder in linux format    
                    payload[url] (str): url to remote file 
            Action:
            -------
                Add file to existing s3

            Returns:
            --------
                status, str: print confirmation 
        ''' 
        try:
            # DETERMINE FILE TYPE 
            if payload["url"] == None:
                #s3_resource.meta.client.upload_file(
                    #Filename=file_name, Bucket=bucket_name,Key=key)
                with open(payload["file_name"], 'rb') as file:
                   self.get_s3_client().upload_fileobj(file, payload["bucket_name"], payload["object_name"])
                self.set_msg(f'FILE {payload["file_name"]} UPLOADED TO {payload["bucket_name"]} SUCCESSFULLY!')
            else: 
                # file = '2021-01-29-0.json.gz'
                object_name = payload["object_name"]
                file = requests.get(f'{payload["url"]}/{payload["file_name"]}')
                #open('2021-01-29-0.json.gz', 'wb').write(file.content)
                #with open (file_name, 'rb') as f:
                self.get_s3_client().upload_fileobj(io.BytesIO(file.content), payload["bucket_name"], object_name)
                self.set_msg(f'FILE {object_name} UPLOADED TO {payload["bucket_name"]} SUCCESSFULLY!')
            return 200,self.get_msg()
        except Exception as e:
            err = f'AN EXCEPTION OCCURED UPLOADING FILE {payload["file_name"]} TO BUCKET {payload["bucket_name"]}\n{e} '
            print(err)
            return 400,self.get_msg()

    def copy_to_bucket(self, from_bucket, to_bucket, file_name):
        '''
        Copy an s3 object from bucket to bucket
            Parameters:
            ----------
                    from_bucket (str) name of bucket to copy from 
                    to_bucket (str): name of bucket to add file to
                    file_name (text file): txt file
            Action:
            -------
            copy file between buckets
                
            Returns:
            --------
                    Name of bucket (str) , s3 response  
        ''' 
        try: 
            copy_source = {
                'Bucket': from_bucket,
                'Key': file_name
            }
            self.get_s3_resource().Object(to_bucket, file_name).copy(copy_source)
            self.set_msg(f'FILE {file_name} COPIED FROM {from_bucket} TO {to_bucket} ')
            print(self.get_msg())
        except Exception as e:
            err = f'AN ERROR OCCURED COPYING {file_name} FROM BUCKET {from_bucket} TO BUCKET {to_bucket}:::\n{e}'
            print(err)


    def delete_files_from_bucket(self, bucket_name, file_list):
        '''
            delete files from existing s3

            Parameters:
            ----------
                file_list(text file): list
                bucket (bucket_name): name of bucket to add file to
            Returns:
            --------
                Name of bucket (str) , s3 response  
        ''' 
        try:
            delete_list = []
            if type(file_list) == list:
                for obj in file_list:
                    response = self.get_s3_client().delete_object(Bucket=bucket_name, Key=obj)
                    self.set_msg(f'{len(file_list)} DELETED!\n\n{response}')
            else:
                self.set_msg(f'{file_list} IS NOT A LIST')
            return 200,  self.get_msg()
        except Exception as e:
            self.set_msg(f'AN OCCURED REMOVING FILES FROM BUCKET {bucket_name}\n{e}')
            print(self.get_msg())
            return 400, self.get_msg()


    def enable_bucket_versioning(self, bucket_name:str):
        '''
        generate a version for a bucket.

            Parameters:
            ----------
                bucket_name (str): string representing bucket name
            Action:
            ------
                creates s3 bucket in aws

            Returns:
            -------
                Name of bucket (str) , s3 response  
        '''
        try: 
            bkt_versioning = self.get_s3_resource().BucketVersioning(bucket_name)
            bkt_versioning.enable()
            self.set_msg(f'VERSION CREATED FOR BUCKET {bucket_name} WITH STATUS {bkt_versioning.status}')
            print(self.get_msg())
        except Exception as e:
            self.set_msg(f'AN EXCEPTION OCCURED CREATING VERSION FOR BUCKET {bucket_name}\n{e}')
            print(self.get_msg())

    def list_iam_roles(self)->tuple:
        """
        Creates a list of all aws iam roles in aws account\n
        uses iam class attribute boto3 aws iam client
            Parameters
                None 
            ----------

            Returns
                list : all aws iam roles in aws account
            ----------
        """
        try: 
            roles_tuple = ()
            roles = []
            arns = []
            response = self.get_iam_client().list_roles()
            for i in range(len(response['Roles'])):
                roles.append(response['Roles'][i]['RoleName'])
                arns.append(response['Roles'][i]['Arn'].split('/')[0])
            # roles_dict = {r[0] : (r[0], r[1]) for r in list(zip(roles, arns))}
                roles_tuple = tuple(zip(roles, arns))
            return roles_tuple
        except Exception as e:
            self.set_msg(f'An error has occured retreiving IAM roles:\n{e} ')
            print(self.get_msg())
            return ("error", self.get_msg())


    def validate_iam_role(self, validate_role)->tuple:
        """
        validates iam role exist in account    
            Parameters
                role (str) : the aws iam role 

            ----------

            Returns
                str : (str) iam role detail  
            ----------
        """
        try:
            role_list =  self.list_iam_roles()
            role_dict = dict(role_list)
            if validate_role in role_dict:
                return (1, validate_role, role_dict[validate_role])
            else:
                return (0, validate_role, self.set_msg(f'ROLE {validate_role} NOT FOUND!'))
        except Exception as e:
            self.set_msg(f'ROLE {validate_role} NOT FOUND!')
            return (0, validate_role, self.get_msg())

    def deploy_function(self, payload: dict)-> str:
        """
        deploys zip file to aws as a lambda  
            Parameters
                role (str) : the aws lambda arn name
                file (str) : the zip of the lambda file that will be deployed
                func_name (str) : the name of the function 
                description (str) : description of the lambda functionality 
                env (str) : environment variables available to the lambda 
            ----------

            Returns
                str : confirmation of deployment  
            ----------
        """    
        try:
            if self.validate_iam_role(payload['role'])[0]== 1:
                role = self.validate_iam_role(payload['role'])[2]
                zip_file = payload['file'] + '.zip'
                with open(zip_file, 'rb') as f:
                    zipped_code = f.read()
                    handler = payload['file'] + '.' + payload['func_name']
                response = self.get_lambda_client().create_function(
                    FunctionName = payload['func_name'],
                    Description = payload['description'],
                    Runtime='python3.13',
                    Role= role,
                    Handler = handler,
                    Code=dict(ZipFile=zipped_code),
                    Timeout=300, # Maximum allowable timeout  
                    Environment = payload['env'],       
                )
                #msg = json.dumps(response, indent=2, default=str)    
                msg = f'LAMBDA CREATED:\nFunction Name: {response["FunctionName"]}\nFunction Arn: {response["FunctionArn"]}'
                print(msg)     
            else: 
                print(f'{payload['role']} not found!')
            
        except Exception as e:
            print(f'An lambda deployment error has occured\n{e} ')


    def invoke_lambda(self, name, test_event):
        """
        invokes aws lambda remotely   
            Parameters
                name (str) : the aws lambda arn name
                test_event (dict) : variables passed to the function 

            ----------

            Returns
                str : confirmation of invocation   
            ----------
        """
        import json 
        try:
            #test_event = dict()
            response = self.lambda_client.invoke(
            FunctionName=name,
            Payload=json.dumps(test_event),  
            )
            msg = response['Payload'].read().decode("utf-8")
            return msg 
        except Exception as e:
            msg = f'EXCEPTION OCCURRED INVOKING LAMBDA {name}\n{e}'
            return msg 


    def describe_lambda(self, name):
        """
        describes aws lambda   
            Parameters
                name (str) : the aws lambda arn name
                file_loc (str) : archive file 

            ----------

            Returns
                str : function name, arn, state, LastUpdateStatus    
            ----------
        """
        try:
            response = self.lambda_client.get_function(
                FunctionName=name
            )
            info = 'FunctionName: ' + str(response['Configuration']['FunctionName']) + '\n'
            info = info + 'FunctionArn: ' + str(response['Configuration']['FunctionArn']) + '\n'
            info = info + 'State: ' + str(response['Configuration']['State']) + '\n'
            info = info + 'LastUpdateStatus: ' + str(response['Configuration']['LastUpdateStatus'])
            return info
        except Exception as e:
            err = f'An error occurred while describing boto20220518\n{e} '
            return err


    def update_function(self, name:str, file_loc:str)->str:
        """
        updates aws lambda code remotely   
            Parameters
                name (str) : the aws lambda arn name
                file_loc (str) : archive file 

            ----------

            Returns
                str : confirmation of update   
            ----------
        """
        try: 
            with open(file_loc, 'rb') as f:
                zipped_code = f.read()

            response = self.lambda_client.update_function_code(
                FunctionName=name,
                ZipFile=zipped_code
            )
            msg = (f'lambda funciton {name} updated')
            print(msg)
            return response
            
        except Exception as e:
            err = f'An error occurred while updating lambda {name}\n{e} '
            return err